Motif finding has been studied extensively in the previous years. Numerous algorithms have been made for motif finding and for PMS. These algorithms are categorized as either approximate algorithms or exact algorithms. This section discusses related algorithms that solves the $(l, d)$-planted motif problem including the EMS-GT algorithm.

\section{Approximate Algorithms}
Approximate algorithms, although they are fast, do not guarantee the exact solution all the time. Heuristic algorithms that perform local search such as Gibbs Sampling, Expectation Maximization (EM),  Projections etc. are previously explored in the literature. Most of these algorithms initially work on a tuple of alignment positions that corresponds to $l$-mers across different string sequences in the dataset. Then they iteratively refine the alignment until a certain criteria has met. MEME \cite{Bailey2006} is a tool for motif finding that implements Expected Maximization. Other approximate algorithms that use local search are GARP \cite{huo2009combining}, GibbsDNA \cite{lawrence1993detecting} and Random Projection \cite{Buhler2001Tompa, huo2009combining}. WINNOWER \cite{pevzner2000combinatorial} reduces the PMS problem to finding a large clique in a multipartite graph. Instead of looking for the motif directly, the algorithm applies a winnowing technique to remove spurious edges that trims the graph representation making it easier to find the motif. Other approximate algorithms are MULTIPROFILER \cite{Keich01102002},  PatternBranching, ProfileBranching \cite{Price27092003} and CONSENSUS \cite{hertz1999identifying};

% explain one or two approximate then list the rest
\section{Exact Algorithms}
Although they may not be as fast as approximate algorithms, exact algorithms return the correct answer all the time. Furthermore, these exact algorithms can be categorized based on their approach in solving the problem. One approach is to generate a common neighborhood out of all $(m - l + 1)^n$ possible positions representing $l$-mer tuples from all string sequences. This approach is called sample-driven. Another approach is called pattern-driven that checks from $\Sigma^l$ possible $l$-mers which are the motifs. 

Many exact algorithms solve the PMS problem using suffix trees and other related data structures. RISO \cite{Carvalho05ahighly}, RISOTTO \cite{Pisanti06risotto}, SPELLER \cite{Sagot98spellingapproximate} and SMILE are all exact algorithms that use suffix trees. MITRA \cite{eskin2002finding} improves the excessive memory requirement of sample-driven approach by using mismatch tree. Two other algorithms that have some similarity with our algorithm are the Voting algorithm and Bit-based algorithm. Voting algorithm \cite{Chin2005} maintains a hash table that tracks the number the occurrence of every possible $l$-mer and makes sure that every $l$-mer is only counted once in each sequence. An $l$-mer is considered a motif if its total occurrences is equal to the total number of sequences in the dataset.

% Further explain the bit-based algorithm
Bit-based algorithm \cite{dasari2010efficient} generates the neighborhood of each sequence and intersects it to get the set of motif. Unlike PMS1, the Bit-based algorithm maps every $l$-mer to its corresponding integer value. It uses an array of size $\Sigma^l$ to represent the neighborhood of a sequence and uses the integer representation of an $l$-mer to flag if its a member of the array. It generates the neighborhood of all sequences and merges it using the logical operator AND. The resulting array represents the set of motif.


\subsection{PMS Algorithms Series}
% PMS Series
A series of exact algorithms for the $(l, d)$-planted motif search problem was developed by Rajasekaran et al. The algorithm PMS1 \cite{ExactAlgorithmsPMS} is one of these algorithms. PMS1 solves the problem by enumerating the $d$-neighborhood of all the sequences in the dataset and intersects them, the result is the set of motifs. PMSi and PMSP \cite{Davila2006} are algorithms based on PMS1. PMSi improves the memory space requirement of PMS1 by processing only two sequences at a time. PMSP works by generating all the $d$-neighborhood of each $l$-mer in the first sequence and testing each $d$-neighbor if it exists in the remaining sequences. PMSPrune \cite{pms2007} works the same as PMP but with some improvements. It generates the neighborhood of an $l$-mer using a branch-and-bound approach and implements a pruning strategy to speedup the testing of $l$-mers. Succeeding algorithms like PMS5 \cite{Dinh2011} and PMS6 \cite{Shibdas2014} extend the ideas of PMS1 and PMSPrune. PMS5 generates the common neighborhood of three $l$-mers from different sequences at a time and uses ILP for the pruning process. PMS6 only differs from PMS5 in the way it determines the three $l$-mers.

Quorum PMS is a generalized version of the $(l, d)$-motif search problem. Instead of finding an $l$-mer that exists in all $n$ sequences, it only considers up to $q$. We can see that a qPMS problem is equal to PMS when $q = n$. The qPMS7 \cite{Dinh2012} is one algorithm that solves the qPMS problem. Algorithm qPMS7 is a generalized version of qPMSPrune (quorum version of PMSPrune) combined with the pruning strategy of PMS5 algorithm. 


\subsubsection{PMS8 and qPMS9 Algorithm}
% PMS8 \cite{pms2014} is an algorithm that combines the sample-driven approach and the pattern-driven approach. First, it chooses $k$-tuple $T$ of $l$-mers from $k$ different sequences and it makes sure that all $l$-mers in $T$ has a common neighbor. Each $l$-mer that belongs to the common neighborhood of the tuple $T$ will be checked if it appears in the remaining $n - k$ sequences. The algorithm qPMS9 \cite{pms2015} improves the sample-driven approach of PMS8 by prioritizing $l$-mers that are highly distant from those already in the tuple resulting in a smaller size of common $d$-neighborhood to test and enables the algorithm to process the quorum version of the PMS problem.

The PMS8 \cite{pms2014} algorithm improved its predecessors by using certain pruning conditions in common neighbor generation of a tuple of $l$-mers. The algorithm is composed of 2 parts, the sample driven part and the pattern driven part. The sample driven patrt generates a tuple of size $k$ from the first $k$ string sequence. The algorithm generates the tuple by choosing an $l$-mer $x$ in sequence $S_i$. After including an $l$-mer in the tuple, the algorithm filters all $l$-mers that has a distance of greater than $2d$ from $x$ in $S_{i+1} ... S_n$ sequences. If the filtering step results to at least one empty row in any sequences in the dataset, it discards $x$ then it proceeds by choosing the next $l$-mer in $S_i$.
If the size of the tuple reached a certain threshold, the algorithm proceeds to the pattern driven part by generating the common neighbors of the $l$-mers in the tuple. In computing the common neighborhood, the algorithm traverses a tree of possible $l$-mers considering some pruning conditions.

% Pruning

PMS8 solves the $(l, d)$-planted motif problem by repeatedly doing the sample driven part and pattern driven part starting from all possible $l$-mers in the first sequence.

% TODO: qPMS9

% --------------------------------------------------------------
\subsection{EMS-GT Algorithm}
\input{contents/chapter_02/ems-gt}


