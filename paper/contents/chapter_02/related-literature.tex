\section{Review of Related Literature}
	Motif finding has been studied extensively in the previous years. Numerous algorithms have been made for motif finding and for PMS. These algorithms are categorized as either approximate algorithms or exact algorithms. Approximate algorithms, although it is fast, do not guarantee the exact solution all the time. Heuristic algorithms that perform local search such as Gibbs Sampling, Expectation Maximization (EM),  Projections etc. are previously explored in the literature. Most of these algorithms initially work on a tuple of alignment positions that corresponds to $l$-mers across different string sequences in the dataset. Then iteratively refine the alignment until a certain criteria has met. MEME \cite{Bailey2006} is a tool for motif finding that implements Expected Maximization. Other approximate algorithms that use local search are GARP \cite{huo2009combining}, GibbsDNA \cite{lawrence1993detecting} and Random Projection \cite{Buhler2001Tompa, huo2009combining}. WINNOWER \cite{pevzner2000combinatorial} reduces the PMS problem into finding a large clique in a multipartite graph. Instead of looking for the motif directly, the algorithm applies a winnowing technique to remove spurious edges that trims the graph representation making it easier to find the motif. Other approximate algorithms are MULTIPROFILER \cite{Keich01102002},  PatternBranching, ProfileBranching \cite{Price27092003} and CONSENSUS \cite{hertz1999identifying};

	% explain one or two approximate then list the rest

	Although it is not as fast as approximate algorithms, exact algorithms return the correct answer all the time. Furthermore, these exact algorithms can be categorized based on their approach in solving the problem. One approach is to generate a common neighborhood out of all $(m - l + 1)^n$ possible positions or $l$-mers from all string sequences. This approach is called sample-driven. Another approach is called pattern-driven that checks from $\Sigma^l$ possible $l$-mers which are the motifs. 

	% PMS Series
	Rajasekaran et. al. proposed a series of exact algorithms for the $(l, d)$-motif search problem. The algorithm PMS1 \cite{ExactAlgorithmsPMS} is one of these algorithms. PMS1 solves the problem by enumerating the $d$-neighborhood of all the sequences in the dataset and intersects them, the result is the set of motifs. PMSi and PMSP \cite{Davila2006} are algorithms based on PMS1. PMSi improves the memory space requirement of PMS1 by processing only two sequences at a time. PMSP works by generating all the $d$-neighborhood of each $l$-mer in the first sequence and testing each $d$-neighbor if it exists in the remaining sequences. PMSPrune \cite{pms2007} works the same as PMP but with some improvements. It generates the neighborhood of an $l$-mer using a branch and bound approach and implements a pruning strategy to speedup the testing of $l$-mers. Succeeding algorithms like PMS5 \cite{Dinh2011} and PMS6 \cite{Shibdas2014} extend the ideas of PMS1 and PMSPrune. PMS5 generates the common neighborhood of three $l$-mers from different sequences at a time and uses ILP for the pruning process. PMS6 only differs from PMS5 in the way it determines the three $l$-mers. Quorum PMS is a generalized version of the $(l, d)$-motif search problem. Instead of finding an $l$-mer that exists in all $n$ sequences, it only considers up to $q$. We can see that a qPMS problem is equal to PMS when $q = n$. The qPMS7 \cite{Dinh2012} is one algorithm that solves the qPMS problem. Algorithm qPMS7 is a generalized version of qPMSPrune (quorum version of PMSPrune) combined with the pruning strategy of PMS5 algorithm. PMS8 \cite{pms2014} is an algorithm that combines the sample-driven approach and the pattern-driven approach. First, it chooses $k$-tuple $T$ of $l$-mers from $k$ different sequences and it makes sure that all $l$-mers in $T$ has a common neighbor. Each $l$-mer that belongs to the common neighborhood of the tuple $T$ will be checked if it appears in the remaining $n - k$ sequences. The current state-of-the-art algorithm qPMS9 \cite{pms2015} improves the sample-driven approach of PMS8 by prioritizing $l$-mers that are highly distant from those already in the tuple resulting in a smaller size of common $d$-neighborhood to test and enables the algorithm to process the quorum version of the PMS problem.

	% Bitbased and Voting 
	Many exact algorithms solve the PMS problem using suffix trees and other related data structures. RISO \cite{Carvalho05ahighly}, RISOTTO \cite{Pisanti06risotto}, SPELLER \cite{Sagot98spellingapproximate} and SMILE are all exact algorithms that use suffix trees. MITRA \cite{eskin2002finding} improves the excessive memory requirement of sample-driven approach by using mismatch tree. Two other algorithms that are similar in how our algorithm works are the Voting algorithm and Bit-based algorithm. Voting algorithm \cite{Chin2005} maintains a hash table that tracks the number the occurrence of every possible $l$-mer and makes sure that every $l$-mer is only counted once in each sequence. An $l$-mer is considered a motif if its total occurrences is equal to the total number of sequences in the dataset. Bit-based algorithm \cite{dasari2010efficient} generates the neighborhood of each sequence and intersects it to get the set of motif. Unlike PMS1, the Bit-based algorithm maps every $l$-mer to its corresponding integer value. It uses an array of size $\Sigma^l$ to represent the neighborhood of a sequence and uses the integer representation of an $l$-mer to flag if its a member of the array. It generates the neighborhood of all sequences and merges it using the logical operator AND. The resulting array represents the set of motif.
